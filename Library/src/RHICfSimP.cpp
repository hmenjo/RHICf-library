#ifndef __RHICFSIMP_CPP__
#define __RHICFSIMP_CPP__

//--------------------------------------------------------------------
// This class is for storing the information of one incident particle in the
// LHCf simulations "Gencol", "DoubleArm" and "End2End".
// 
// The coordinate systems
// 
//
//   - "End2End" system
//           
//Begin_Html
/*
<img src="fig/coordinatesystem_end2end.gif">
*/
//End_Html
// 
//      The figure is for the case that detectors are on the beam center position.
//      !! Warning !! 
//       the origin of the End2End coordinate system is "NOT" equal to 
//       the beam pipe center. Because the incident position of particles,
//       output of DoubleArm , are shifted a bit to take account of the shift of 
//       detector position from ideal position before End2End.  
//
//        Beam pipe center in Arm1 = ( -1.6, 0.0 )
//                         in Arm2 = ( -0.6, 0.0 )    .
//        It is according to the Sako's analysis resutls of the survey.
//
//   - "Calorimeter" system
//
//Begin_Html
/*
<img src="fig/coordinatesystem_cal.gif">
*/
//End_Html             
// 
//      The definition of this coordinate system is independent 
//      on the actual detector position.  
//
//
//
// Variables: 
//   Particle definitin in EPICS. For detail, see the EPICS manual.
//   - int code;
//     almost kinds of particles are identify by this number and charge.
//      1  :  gamma-ray
//      2  :  electron / positron
//      3  :  muons 
//      4  :  pions 
//      5  :  keons
//      6  :  proton / antiproton / neutron
//            See the manual for the others
//
//   - int subcode; 
//      Only some special particles have a meaningful value.
//      For example, identify which K0-short or K0-long. 
//               
//   - int charge;
//      Charge of the particle.
//
//   - int user;
//      In "DoubleArm" and "End2End" the number of the parent partile
//      in the generator (Gencol.) is filled. If the number has a 
//      negative value, the particle is generated by the secondary-beam pipe
//      interaction.
//   
//   - double pos[3]
//      Insident position on the coordinate system of End2End.
//      Unit [mm]  
//      
//   - double energy
//      Total energy. [GeV]
// 
//   - double mom[3]
//      Momentum [GeV/c] 
//       
//  HOW TO USE
//    - To get the incident position in the "Calorimeter" system from "End2End"
//      Use CalPosX() and CalPosY()
//
//    - To check whether the particle hits the calorimeter, 
//      Use CheckHit()
// 
//  HOW TO GET THE INCIDENT POSITION IN SEVERAL COORDINATE (3 Dec. 2015 by Menjo)
//   The incident position of the particle can be provided in several coodrinate. 
//    (1) Global Detector  : The origin is located on the center of detctor (see the fig)
//    (2) Global Beam Pipe : The origin is located on the center of beam pipe 
//                           = the coordinate system of End2End output
//    (3) Global Beam Center : The origin is located on the beam center. 
//    These three coodinate can be converted by a simple shift with the corresponding 
//    parameters while the conversion to/from calorimeter coordinate needs a rotation 
//    also in case of Arm1. 
//    The incident position can be got by the functions 
//    (1) -> GlobalPos_Detector(xy, offsetx, offsety) 
//    (2) -> GlobalPos_BeamPipe(xy)
//    (3) -> GlobalPos_BC(xy,offsetx, offsety)
//    These offsetx,offsety which are shift paramters must be specified. 
//    The offsets are automatticaly calculated if the beam center and the beam pipe 
//    position on the global detector coordinate system are given via a static 
//    function,  SetPositionBeamCenter(x,y) and  SetPositionBeamPipeCenter(x,y).
//    An example 
//         SimP::SetPositionBeamCenter(1.0,1.0);
//         SimP::SetPositionBeamPipeCenter(0.0,20.0);  
//         then 
//         cout << pp->GlobalPosX_BC() << endl;
//    !! Important !! 
//      Both PositionBeamCenter and PositionBeamPipeCenter must be given 
//      even you call only GlobalPosX(Y)_BC. 
//
//Begin_Html
/*
<img src="fig/coordinatesystem_global.png">
*/
//End_Html
//
//
// +++ Logs ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  ?? ???. 08: First edited by H.MENJO
//  28 Jan. 10: Added functions of IsPhoton() etc.
//  02 Dec. 15: Added functions as GlobalPos_Detector by Menjo 
//-------------------------------------------------------------------


#include "RHICfSimP.h"

#if !defined(__CINT__)
ClassImp(RHICfSimP);
#endif

#include <iostream>
#include "TDatabasePDG.h"
#include "TLorentzVector.h"
#include "TVector3.h"
#include <iomanip>
#include <math.h>
using namespace std;

// Static valuables.
double RHICfSimP::sPositionBeamCenter[2] = {0.};
double RHICfSimP::sPositionBeamPipe[2]   = {0.};

int RHICfSimP::clear(){
  // Clear the all data.
  
  //  code = 0;
  //  subcode = 0;
  //  charge = 0;
  pdgcode=0;
  user = 0;
  energy = 0;
  for(int i=0;i<3;i++){
    pos[i] = 0.;
    mom[i] = 0.;
  }
  return 1;
}


int RHICfSimP::copy(RHICfSimP* d){
  // Copy all data, name and tile.
  
  this->SetName(d->GetName());
  this->SetTitle(d->GetTitle());
  return copydata(d);
}


int RHICfSimP::copydata(RHICfSimP* d){
  // Copy only the data 

  this->pdgcode = d->pdgcode;
  //  this->code = d->code;
  //  this->subcode = d->subcode;
  //  this->charge = d->charge;
  this->user = d->user;
  this->energy = d->energy;
  for(int i=0;i<3;i++){
    this->pos[i] = d->pos[i];
    this->mom[i] = d->mom[i];
  }
  return 1;
} 

double RHICfSimP::PosX(){
  // Hit X-position "on the calorimeter surface"
  // Extraporate the position on End2End surface (the front of TAN) 
  // to the position on the calorimeter surface by using pos and mom
  //  const double distanceTANtoCal = 1245.;  //[mm]
  const double distanceTANtoCal = 0.;  //[mm]
  double momentum = Momentum();
  if(momentum>0.){
    return pos[0] + MomX()/momentum*distanceTANtoCal;
  }
  else{
    return pos[0];
  }
}

double RHICfSimP::PosY(){ 
  // Hit Y-position "on the calorimeter surface"
  // Extraporate the position on End2End surface (the front of TAN) 
  // to the position on the calorimeter surface by using pos and mom
  //  const double distanceTANtoCal = 1245.;  //[mm]
  const double distanceTANtoCal = 0.;  //[mm]
  double momentum = Momentum();
  if(momentum>0.){
    return pos[1] + MomY()/momentum*distanceTANtoCal;
  }
  else{
    return pos[1];
  } 
}

double RHICfSimP::PosZ(){
  // Hit Z-position "on the calorimeter surface"
  // return  1398.00 cm (TAN surface) 
  //        +124.5 cm (From TAN surface to calorimeter surface)
  //  const double distanceTANtoCal = 1245.;  //[mm]
  //  const double distancefromIP = 13980.0;  //[mm]
  const double distanceTANtoCal = 0.;  //[mm]
  const double distancefromIP = 17799.7;  //[mm]
  return distancefromIP + distanceTANtoCal;
}

double RHICfSimP::KineticEnergy(){
  // Energy() - Mass() 
  // Unit : GeV
  return energy - Mass();
}

double RHICfSimP::Mass(){
  // Mass of the particle. [GeV]
  // Mass are given only for the following partciles.
  //   photon     :  0 
  //   e+/e-      :  0.000511
  //   muon       :  0.1056
  //   pi0        :  0.1350
  //   pi+/pi-    :  0.1396
  //   K0         :  0.4977
  //   K+-        :  0.4937
  //   p          :  0.9396
  //   n          :  0.9383
  //   lambda     :  1.1157
  //   sigma+     :  1.1894
  //   sigma-     :  1.1974
  //   sigma0     :  1.1926
  //   xi0        :  1.3148
  //   xi+-       :  1.3213
  //   eta        :  0.5473
  //   the others give 0 .

  return TDatabasePDG::Instance()->GetParticle(pdgcode)->Mass();

  /*
  if(code==1){ return 0;}            // photon
  if(code==2){ return 0.000511;}     // electron
  if(code==3){ return 0.1056;}       // muon
  if(code==4){                       // pion
    if(charge==0){return 0.1350;}
    else {return 0.1396;}
  }
  if(code==5){                       // keon
    if(charge==0){return 0.4977;}
    else{return 0.4937;}
  }
  if(code==6){                       // proton, neutron 
    if(charge==0){return 0.9396;}
    else{return 0.9383;}
  }
  if(code==18){return 1.1157;}       // lambda
  if(code==19){                      // sigma
    if(charge==1){return 1.1894;}
    else if(charge==-1){return 1.1974;}
    else {return 1.1926;}
  }
  if(code==20){                      // xi
    if(charge==0){return 1.3148;}
    else{ return 1.3213;}
  }
  if(code==28){ return 0.5473;}      // eta
  return 0.;
  */
}

double RHICfSimP::Momentum(){
  // Momentum [GeV]
  // sqrt(mom[0]*mom[0]+mom[1]*mom[1]+mom[2]*mom[2]);
  return sqrt(mom[0]*mom[0]+mom[1]*mom[1]+mom[2]*mom[2]);
}

void RHICfSimP::CalPos(int id,int it,double &x,double &y,
		  double offsetx,
		  double offsety){
  // Incident position on the calorimeter coordinate system.
  //  id      :  detector 1:Old Arm1, 2:Old Arm2, 10:New Arm1, 20: New Arm2
  //  it      :  calorimeter tower (0 (20mm or 25mm) or 1 (40mm or 32mm))
  //  x       :  x on the calorimeter system [return] 
  //  y       :  y on the calorimeter system [return] 
  //  offsetx :  x offset of the detector position
  //  offsety :  y offset of the detector position
  //    example in case that the detector is on 20mm below the beam center position.
  //    offsetx = 0.0, offsety = -20.0
  //

  double tmpx,tmpy;
  double s2 = sqrt(2.);
  x = PosX() - offsetx;
  y = PosY() - offsety;
  // Old Detector : 20mm calorimeter
  if(id==1 && (it==0 || it==20)){
    // shift
    tmpx = x;
    tmpy = y + 20./s2;
    // rotation
    x =     tmpx/s2 + tmpy/s2;
    y = -1.*tmpx/s2 + tmpy/s2;
    return ;
  }
  // Old Detector : 40mm calorimeter
  else if(id==1 && (it==1 || it==40)){
    // shift
    tmpx = x;
    tmpy = y -20./s2-5.0;
    // rotation
    x =     tmpx/s2 + tmpy/s2;
    y = -1.*tmpx/s2 + tmpy/s2;
    return ;
  }
  // Old Detector : 25mm calorimeter
  else if(id==2 && (it==0 || it==25)){
    // shift
    x += 17.0;
    y += 12.5;
    return ;
  }
  // Old Detector : 32mm calorimeter
  else if(id==2 && (it==1 || it==32)){
    // shift
    x += -9.8;
    y += -14.3;
    return ;
  }  
  // New Detector : 20mm calorimeter
  else if(id==10 && (it==0 || it==20)){
    // shift
    tmpx = x;
    tmpy = y + 20./s2;
    // rotation
    x =     tmpx/s2 + tmpy/s2;
    y = -1.*tmpx/s2 + tmpy/s2;
    return ;
  }
  // New Detector : 40mm calorimeter
  else if(id==10 && (it==1 || it==40)){
    // shift
    tmpx = x;
    tmpy = y -20./s2-5.0;
    // rotation
    x =     tmpx/s2 + tmpy/s2;
    y = -1.*tmpx/s2 + tmpy/s2;
    return ;
  }
  // New Detector : 25mm calorimeter
  else if(id==20 && (it==0 || it==25)){
    // shift
    x += -17.0;
    y += 12.5;
    return ;
  }
  // New Detector : 32mm calorimeter
  else if(id==20 && (it==1 || it==32)){
    // shift
    x +=  9.8;
    y += -14.3;
    return ;
  } 
  
  x = -100.;
  y = -100.;
}

double RHICfSimP::CalPosX(int id,int it,
		     double offsetx,
		     double offsety){
  // CalPos(id,it,x,y,offsetx,offsety);
  // return x;
  double x,y;
  CalPos(id,it,x,y,offsetx,offsety);
  return x;
}

double RHICfSimP::CalPosY(int id,int it,
		     double offsetx,
		     double offsety){
  // CalPos(id,it,x,y,offsetx,offsety);
  // return y
  double x,y;
  CalPos(id,it,x,y,offsetx,offsety);
  return y;
}

int RHICfSimP::CheckHit(int id,int it,double edgecut,
		   double offsetx,
		   double offsety){
  // Check if the particle hits the calorimeter or not.
  // If the perticle is in the acceptance of calorimeter, return 1.
  // if not, return 0.
  // The acceptance can be defined by using the edgecut parameter.
  //  
  //  id      :  detector 1:Old Arm1, 2:Old Arm2, 10:New Arm1, 20: New Arm2
  //  it      :  calorimeter tower (0 (20mm or 25mm) or 1 (40mm or 32mm))
  //             also just the size of cal. 20, 40, 25, 32 are acceptable.
  //  edgecut :  Distance from edge of your acceptable area. [default: 0]   
  //             in case of 2mm inside, give 2.0 .    
  //  offsetx :  x offset of the detector position [default: 0.0]
  //  offsety :  y offset of the detector position [default: 0.0]
  // 
  // !! Warning !! 
  // The position of RHICfSimP is in the front of TAN ( in the front of Y-chember.)
  // Even it give "1", it is not sure that the particle actually hits the calorimeter.
  // for example, low energy partiles might be scattered in the beam pipe of 
  // Y-chember.
  // 
  double x,y,size;
  CalPos(id,it,x,y,offsetx,offsety);
  size = GetCalorimeterSize(id,it);
  if(size<1.) return 0; // error 

  if(x>0.+edgecut && x<size-edgecut && 
     y>0.+edgecut && y<size-edgecut ){
    return 1;
  }
  
  return 0;
}

double RHICfSimP::GetCalorimeterSize(int id,int it){
  // Return the calorimeter size
  if(id==1  && (it==0 || it==20)){ return 20.;}
  if(id==1  && (it==1 || it==40)){ return 40.;}
  if(id==2  && (it==0 || it==25)){ return 25.;}
  if(id==2  && (it==1 || it==32)){ return 32.;}
  if(id==10 && (it==0 || it==20)){ return 20.;}
  if(id==10 && (it==1 || it==40)){ return 40.;}
  if(id==20 && (it==0 || it==25)){ return 25.;}
  if(id==20 && (it==1 || it==32)){ return 32.;}  
  return 0.;
}

void RHICfSimP::Show(int id,int it,double offsetx,double offsety){
  // Print the information of the particle.
  //   id  :   detector. if id==0, show the position on the End2End system.
  //   it  :   calorimeter tower. 
  //           if it==-1, shower positions on the End2End and calorimeters system.
  //   offsetx , offsety : offset of the detector position
  // 
  int check=0;
  double x[3],y[3];
  if(id==1 || id==2 || id==10 || id==20){
    if(it==0 || it==1 || it==20 || it==40 || it==25 || it==32){
      check=1;
      x[0] = CalPosX(id,it,offsetx,offsety);
      y[0] = CalPosY(id,it,offsetx,offsety);
    }
    else{
      check=3;
      x[0] = PosX();
      y[0] = PosY();
      x[1] = CalPosX(id,0,offsetx,offsety);
      y[1] = CalPosY(id,0,offsetx,offsety); 
      x[2] = CalPosX(id,1,offsetx,offsety);
      y[2] = CalPosY(id,1,offsetx,offsety);
    }
  }
  else {
    check=1;
    x[0] = PosX();
    y[0] = PosY();
  }
  ios::fmtflags cflags;
  cflags = cout.flags();
  cout.setf(ios::fixed);
  //  cout << setw(2) << code << " " 
  //       << setw(3) << subcode << " "
  //       << setw(3) << charge << " "
  cout << setw(8) << pdgcode << " "
       << setw(5) << user << "  "
       << setw(8) << setprecision(1) << KineticEnergy() << "   ";
  for(int i=0;i<check;i++){
    cout << setw(6) << setprecision(2) << x[i] << " " 
	 << setw(6) << setprecision(2) << y[i] << "  ";
  }
  cout << endl; 
  cout.flags(cflags);
  return ;
}

// *****************************************************************
// *****        FOR CONVERSION OF POSITION COORDINATE          *****
// *****************************************************************

int RHICfSimP::SetPositionBeamCenter(double x,double y){
  // Static function for setting the static paramter for the beam center position 
  // x and y must be a beam center position on the global detector coordinate system
  sPositionBeamCenter[0] = x;
  sPositionBeamCenter[1] = y;
  return 0;
}

int RHICfSimP::SetPositionBeamPipeCenter(double x,double y){
  // Static function for setting the static paramter for the beam pipe center.
  // x and y must be a beam pipe center on the global detector coordinate system
  // Example : the zero crossing angle -> (x,y) = (0,0)
  //           145urad crossing angle  -> (x,y) = (0,20.45)
  sPositionBeamPipe[0] = x;
  sPositionBeamPipe[1] = y;
  return 0;
}


double RHICfSimP::PositionShift(int ixy, double offsetx, double offsety){
  // Simple function which internally used. 
  return ixy==0? (PosX()+offsetx) : (PosY()+offsety);
}

double RHICfSimP::GlobalPos_Detector( int ixy, 
				 double offsetx,
				 double offsety){
  // Return the incident position in the global detector coordinate (The origin is the ideal detector center.). 
  // The offset paramters should be the detector center position on the global beam pipe coordinate system 
  // If offsetx, offsety are not given, the defaults value which are calculated from SetPositionBeamPipeCenter()
  // sPositionBeamPipe, are used. The sPositionBeamPipe can be setted by ()
  return PositionShift(ixy, offsetx, offsety);
}

double RHICfSimP::GlobalPos_BC(int ixy, 
			  double offsetx,
			  double offsety){
  // Return the incident position in the global beam center coordinate. 
  // The offset paramters should be the beam center position on the global beam pipe coordinate system 
  // If offsetx, offsety are not given, the defaults value which are calculated from 
  // sPositionBeamCenter and sPositionBeamPipe, are used. The sPositionBeamCenter/sPositionBeamPipe 
  // can be setted by SetPositionBeamCenter() and SetPositionBeamPipeCenter()
  return PositionShift(ixy, offsetx, offsety);
}

double RHICfSimP::GlobalPos_BeamPipe(int ixy){
  // Return the incident position in the global beam pipe coordinate.
  return PositionShift(ixy, 0.0, 0.0); 
}

void RHICfSimP::Clear()
{
    Name = "";
    FMomentum = TLorentzVector(0, 0, 0, 0);
    Position = TVector3(0, 0, 0);
    OriginalPName = "";
    OriginalP4Momentum = TLorentzVector(0, 0, 0, 0);
    OriginalPPosition = TVector3(0, 0, 0);
    TrackID = 0;
    Tower = -1;
}

void RHICfSimP::SetName(TString tmps)
{
    Name = tmps;
}

void RHICfSimP::Set4Momentum(TLorentzVector tmp4vec)
{
    FMomentum = tmp4vec;
}

void RHICfSimP::SetPosition(TVector3 tmp3vec)
{
    Position = tmp3vec;
}

void RHICfSimP::SetOriginalPName(TString tmps)
{
    OriginalPName = tmps;
}

void RHICfSimP::SetOriginalP4Momentum(TLorentzVector tmp4vec)
{
    OriginalP4Momentum = tmp4vec;
}

void RHICfSimP::SetOriginalPPosition(TVector3 tmp3vec)
{
    OriginalPPosition = tmp3vec;
}

void RHICfSimP::SetTrackID(Int_t tmpi)
{
    TrackID = tmpi;
}

void RHICfSimP::SetTower(Int_t tmptower)
{
    Tower = tmptower;
}

TVector3 RHICfSimP::GetFramePosition(const Double_t& offset)
{
    TVector3 tmpvec3;
    
    return tmpvec3;
}

RHICfSimP::RHICfSimP(const RHICfSimP &rhs): Name(rhs.Name), FMomentum(rhs.FMomentum), Position(rhs.Position), OriginalPName(rhs.OriginalPName), OriginalPPosition(rhs.OriginalPPosition), OriginalP4Momentum(rhs.OriginalP4Momentum), TrackID(rhs.TrackID), Tower(rhs.Tower)
{

}

RHICfSimP& RHICfSimP::operator=(const RHICfSimP& rhs)
{
    TNamed::operator=(rhs);
    Name = rhs.Name;
    FMomentum = rhs.FMomentum;
    Position = rhs.Position;
    OriginalPName = rhs.OriginalPName;
    OriginalPPosition = rhs.OriginalPPosition;
    OriginalP4Momentum = rhs.OriginalP4Momentum;
    TrackID = rhs.TrackID;
    Tower = rhs.Tower;
    return *this;

}
  

#endif

