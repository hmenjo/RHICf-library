#ifndef __RHICFSIMP_CPP__
#define __RHICFSIMP_CPP__

//--------------------------------------------------------------------
// This class is for storing the information of one incident particle in the
// LHCf simulations "Gencol", "DoubleArm" and "End2End".
// 
// The coordinate systems
// 
//
//   - "End2End" system
//           
//Begin_Html
/*
<img src="fig/coordinatesystem_end2end.gif">
*/
//End_Html
// 
//      The figure is for the case that detectors are on the beam center position.
//      !! Warning !! 
//       the origin of the End2End coordinate system is "NOT" equal to 
//       the beam pipe center. Because the incident position of particles,
//       output of DoubleArm , are shifted a bit to take account of the shift of 
//       detector position from ideal position before End2End.  
//
//        Beam pipe center in Arm1 = ( -1.6, 0.0 )
//                         in Arm2 = ( -0.6, 0.0 )    .
//        It is according to the Sako's analysis resutls of the survey.
//
//   - "Calorimeter" system
//
//Begin_Html
/*
<img src="fig/coordinatesystem_cal.gif">
*/
//End_Html             
// 
//      The definition of this coordinate system is independent 
//      on the actual detector position.  
//
//
//
// Variables: 
//   Particle definitin in EPICS. For detail, see the EPICS manual.
//   - int code;
//     almost kinds of particles are identify by this number and charge.
//      1  :  gamma-ray
//      2  :  electron / positron
//      3  :  muons 
//      4  :  pions 
//      5  :  keons
//      6  :  proton / antiproton / neutron
//            See the manual for the others
//
//   - int subcode; 
//      Only some special particles have a meaningful value.
//      For example, identify which K0-short or K0-long. 
//               
//   - int charge;
//      Charge of the particle.
//
//   - int user;
//      In "DoubleArm" and "End2End" the number of the parent partile
//      in the generator (Gencol.) is filled. If the number has a 
//      negative value, the particle is generated by the secondary-beam pipe
//      interaction.
//   
//   - double pos[3]
//      Insident position on the coordinate system of End2End.
//      Unit [mm]  
//      
//   - double energy
//      Total energy. [GeV]
// 
//   - double mom[3]
//      Momentum [GeV/c] 
//       
//  HOW TO USE
//    - To get the incident position in the "Calorimeter" system from "End2End"
//      Use CalPosX() and CalPosY()
//
//    - To check whether the particle hits the calorimeter, 
//      Use CheckHit()
// 
//  HOW TO GET THE INCIDENT POSITION IN SEVERAL COORDINATE (3 Dec. 2015 by Menjo)
//   The incident position of the particle can be provided in several coodrinate. 
//    (1) Global Detector  : The origin is located on the center of detctor (see the fig)
//    (2) Global Beam Pipe : The origin is located on the center of beam pipe 
//                           = the coordinate system of End2End output
//    (3) Global Beam Center : The origin is located on the beam center. 
//    These three coodinate can be converted by a simple shift with the corresponding 
//    parameters while the conversion to/from calorimeter coordinate needs a rotation 
//    also in case of Arm1. 
//    The incident position can be got by the functions 
//    (1) -> GlobalPos_Detector(xy, offsetx, offsety) 
//    (2) -> GlobalPos_BeamPipe(xy)
//    (3) -> GlobalPos_BC(xy,offsetx, offsety)
//    These offsetx,offsety which are shift paramters must be specified. 
//    The offsets are automatticaly calculated if the beam center and the beam pipe 
//    position on the global detector coordinate system are given via a static 
//    function,  SetPositionBeamCenter(x,y) and  SetPositionBeamPipeCenter(x,y).
//    An example 
//         SimP::SetPositionBeamCenter(1.0,1.0);
//         SimP::SetPositionBeamPipeCenter(0.0,20.0);  
//         then 
//         cout << pp->GlobalPosX_BC() << endl;
//    !! Important !! 
//      Both PositionBeamCenter and PositionBeamPipeCenter must be given 
//      even you call only GlobalPosX(Y)_BC. 
//
//Begin_Html
/*
<img src="fig/coordinatesystem_global.png">
*/
//End_Html
//
//
// +++ Logs ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  ?? ???. 08: First edited by H.MENJO
//  28 Jan. 10: Added functions of IsPhoton() etc.
//  02 Dec. 15: Added functions as GlobalPos_Detector by Menjo 
//-------------------------------------------------------------------


#include "RHICfSimP.h"

#if !defined(__CINT__)
ClassImp(RHICfSimP);
#endif

#include <iostream>
#include "TDatabasePDG.h"
#include "TLorentzVector.h"
#include "TVector3.h"
#include <iomanip>
#include <math.h>
using namespace std;

// Static const
const double RHICfSimP::cDistancefromIP =  17799.7;

// Static valuables.
double RHICfSimP::sPositionBeamCenter[2] = {0.};
double RHICfSimP::sPositionBeamPipe[2]   = {0.};

int RHICfSimP::clear(){
  // Clear the all data.
  
  //  code = 0;
  //  subcode = 0;
  //  charge = 0;
 
  Clear();
  return 1;
}


int RHICfSimP::copy(RHICfSimP* d){
  // Copy all data
  // For compatibility with old LHCf class
  
  Copy(*d);
  return 1;
}


int RHICfSimP::copydata(RHICfSimP* d){
  // Copy only the data 
  // For compatibility with old LHCf class
  Copy(*d);
  return 1;
} 

double RHICfSimP::PosX(){
  // Hit X-position "on the calorimeter surface"
  // The position is projected to the surface with considering the direction 
  // of the particle 

  double momentum = Momentum();
  double pos,d,dir;
  pos  = fPosition.X();
  d    = cDistancefromIP - fPosition.Z();
  dir  = fFMomentum.Px()/Momentum();
  if(momentum>0.){
    return pos + d*dir;
  }
  else{
    return pos;
  }
}

double RHICfSimP::PosY(){ 
  // Hit Y-position "on the calorimeter surface"
  double momentum = Momentum();
  double pos,d,dir;
  pos  = fPosition.Y();
  d    = cDistancefromIP - fPosition.Z();
  dir  = fFMomentum.Py()/Momentum();
  if(momentum>0.){
    return pos + d*dir;
  }
  else{
    return pos;
  }
}

double RHICfSimP::PosZ(){
  // Hit Z-position "on the calorimeter surface"
  return cDistancefromIP;
}

double RHICfSimP::KineticEnergy(){
  // Energy() - Mass() 
  // Unit : GeV
  return fFMomentum.Energy() - Mass();
}

double RHICfSimP::Mass(){
  // Mass of the particle. [GeV]
  return TDatabasePDG::Instance()->GetParticle(fPdgcode)->Mass();
}

double RHICfSimP::Momentum(){
  // Momentum [GeV]
  return fFMomentum.P();
}

void RHICfSimP::CalPos(int id,int it,double &x,double &y,
		  double offsetx,
		  double offsety){
  // Incident position on the calorimeter coordinate system.
  //  id      :  detector 1:Old Arm1, 2:Old Arm2, 10:New Arm1, 20: New Arm2
  //  it      :  calorimeter tower (0 (20mm or 25mm) or 1 (40mm or 32mm))
  //  x       :  x on the calorimeter system [return] 
  //  y       :  y on the calorimeter system [return] 
  //  offsetx :  x offset of the detector position
  //  offsety :  y offset of the detector position
  //    example in case that the detector is on 20mm below the beam center position.
  //    offsetx = 0.0, offsety = -20.0
  //

  double tmpx,tmpy;
  double s2 = sqrt(2.);
  x = PosX() - offsetx;
  y = PosY() - offsety;
  // Old Detector : 20mm calorimeter
  if(id==1 && (it==0 || it==20)){
    // shift
    tmpx = x;
    tmpy = y + 20./s2;
    // rotation
    x =     tmpx/s2 + tmpy/s2;
    y = -1.*tmpx/s2 + tmpy/s2;
    return ;
  }
  // Old Detector : 40mm calorimeter
  else if(id==1 && (it==1 || it==40)){
    // shift
    tmpx = x;
    tmpy = y -20./s2-5.0;
    // rotation
    x =     tmpx/s2 + tmpy/s2;
    y = -1.*tmpx/s2 + tmpy/s2;
    return ;
  }
  // Old Detector : 25mm calorimeter
  else if(id==2 && (it==0 || it==25)){
    // shift
    x += 17.0;
    y += 12.5;
    return ;
  }
  // Old Detector : 32mm calorimeter
  else if(id==2 && (it==1 || it==32)){
    // shift
    x += -9.8;
    y += -14.3;
    return ;
  }  
  // New Detector : 20mm calorimeter
  else if(id==10 && (it==0 || it==20)){
    // shift
    tmpx = x;
    tmpy = y + 20./s2;
    // rotation
    x =     tmpx/s2 + tmpy/s2;
    y = -1.*tmpx/s2 + tmpy/s2;
    return ;
  }
  // New Detector : 40mm calorimeter
  else if(id==10 && (it==1 || it==40)){
    // shift
    tmpx = x;
    tmpy = y -20./s2-5.0;
    // rotation
    x =     tmpx/s2 + tmpy/s2;
    y = -1.*tmpx/s2 + tmpy/s2;
    return ;
  }
  // New Detector : 25mm calorimeter
  else if(id==20 && (it==0 || it==25)){
    // shift
    x += -17.0;
    y += 12.5;
    return ;
  }
  // New Detector : 32mm calorimeter
  else if(id==20 && (it==1 || it==32)){
    // shift
    x +=  9.8;
    y += -14.3;
    return ;
  } 
  
  x = -100.;
  y = -100.;
}

double RHICfSimP::CalPosX(int id,int it,
		     double offsetx,
		     double offsety){
  // CalPos(id,it,x,y,offsetx,offsety);
  // return x;
  double x,y;
  CalPos(id,it,x,y,offsetx,offsety);
  return x;
}

double RHICfSimP::CalPosY(int id,int it,
		     double offsetx,
		     double offsety){
  // CalPos(id,it,x,y,offsetx,offsety);
  // return y
  double x,y;
  CalPos(id,it,x,y,offsetx,offsety);
  return y;
}

int RHICfSimP::CheckHit(int id,int it,double edgecut,
		   double offsetx,
		   double offsety){
  // Check if the particle hits the calorimeter or not.
  // If the perticle is in the acceptance of calorimeter, return 1.
  // if not, return 0.
  // The acceptance can be defined by using the edgecut parameter.
  //  
  //  id      :  detector 1:Old Arm1, 2:Old Arm2, 10:New Arm1, 20: New Arm2
  //  it      :  calorimeter tower (0 (20mm or 25mm) or 1 (40mm or 32mm))
  //             also just the size of cal. 20, 40, 25, 32 are acceptable.
  //  edgecut :  Distance from edge of your acceptable area. [default: 0]   
  //             in case of 2mm inside, give 2.0 .    
  //  offsetx :  x offset of the detector position [default: 0.0]
  //  offsety :  y offset of the detector position [default: 0.0]
  // 
  // !! Warning !! 
  // The position of RHICfSimP is in the front of TAN ( in the front of Y-chember.)
  // Even it give "1", it is not sure that the particle actually hits the calorimeter.
  // for example, low energy partiles might be scattered in the beam pipe of 
  // Y-chember.
  // 
  double x,y,size;
  CalPos(id,it,x,y,offsetx,offsety);
  size = GetCalorimeterSize(id,it);
  if(size<1.) return 0; // error 

  if(x>0.+edgecut && x<size-edgecut && 
     y>0.+edgecut && y<size-edgecut ){
    return 1;
  }
  
  return 0;
}

double RHICfSimP::GetCalorimeterSize(int id,int it){
  // Return the calorimeter size
  if(id==1  && (it==0 || it==20)){ return 20.;}
  if(id==1  && (it==1 || it==40)){ return 40.;}
  if(id==2  && (it==0 || it==25)){ return 25.;}
  if(id==2  && (it==1 || it==32)){ return 32.;}
  if(id==10 && (it==0 || it==20)){ return 20.;}
  if(id==10 && (it==1 || it==40)){ return 40.;}
  if(id==20 && (it==0 || it==25)){ return 25.;}
  if(id==20 && (it==1 || it==32)){ return 32.;}  
  return 0.;
}

void RHICfSimP::Show(int id,int it,double offsetx,double offsety){
  // Print the information of the particle.
  //   id  :   detector. if id==0, show the position on the End2End system.
  //   it  :   calorimeter tower. 
  //           if it==-1, shower positions on the End2End and calorimeters system.
  //   offsetx , offsety : offset of the detector position
  // 
  int check=0;
  double x[3],y[3];
  if(id==1 || id==10){
    if(it==0 || it==1 || it==20 || it==40 ){
      check=1;
      x[0] = CalPosX(id,it,offsetx,offsety);
      y[0] = CalPosY(id,it,offsetx,offsety);
    }
    else{
      check=3;
      x[0] = PosX();
      y[0] = PosY();
      x[1] = CalPosX(id,0,offsetx,offsety);
      y[1] = CalPosY(id,0,offsetx,offsety); 
      x[2] = CalPosX(id,1,offsetx,offsety);
      y[2] = CalPosY(id,1,offsetx,offsety);
    }
  }
  else {
    check=1;
    x[0] = PosX();
    y[0] = PosY();
  }

  ios::fmtflags cflags;
  cflags = cout.flags();
  cout.setf(ios::fixed);
  cout << setw(8) << fPdgcode << " "
       << setw(5) << fTrackID << "  "
       << setw(8) << setprecision(1) << KineticEnergy() << "   ";
  for(int i=0;i<check;i++){
    cout << setw(6) << setprecision(2) << x[i] << " " 
			<< setw(6) << setprecision(2) << y[i] << "  ";
  }
  cout << endl; 
  cout.flags(cflags);
  return ;
}

// *****************************************************************
// *****        FOR CONVERSION OF POSITION COORDINATE          *****
// *****************************************************************

int RHICfSimP::SetPositionBeamCenter(double x,double y){
  // Static function for setting the static paramter for the beam center position 
  // x and y must be a beam center position on the global detector coordinate system
  sPositionBeamCenter[0] = x;
  sPositionBeamCenter[1] = y;
  return 0;
}

int RHICfSimP::SetPositionBeamPipeCenter(double x,double y){
  // Static function for setting the static paramter for the beam pipe center.
  // x and y must be a beam pipe center on the global detector coordinate system
  // Example : the zero crossing angle -> (x,y) = (0,0)
  //           145urad crossing angle  -> (x,y) = (0,20.45)
  sPositionBeamPipe[0] = x;
  sPositionBeamPipe[1] = y;
  return 0;
}


double RHICfSimP::PositionShift(int ixy, double offsetx, double offsety){
  // Simple function which internally used. 
  return ixy==0? (PosX()+offsetx) : (PosY()+offsety);
}

double RHICfSimP::GlobalPos_Detector( int ixy, 
				 double offsetx,
				 double offsety){
  // Return the incident position in the global detector coordinate (The origin is the ideal detector center.). 
  // The offset paramters should be the detector center position on the global beam pipe coordinate system 
  // If offsetx, offsety are not given, the defaults value which are calculated from SetPositionBeamPipeCenter()
  // sPositionBeamPipe, are used. The sPositionBeamPipe can be setted by ()
  return PositionShift(ixy, offsetx, offsety);
}

double RHICfSimP::GlobalPos_BC(int ixy, 
			  double offsetx,
			  double offsety){
  // Return the incident position in the global beam center coordinate. 
  // The offset paramters should be the beam center position on the global beam pipe coordinate system 
  // If offsetx, offsety are not given, the defaults value which are calculated from 
  // sPositionBeamCenter and sPositionBeamPipe, are used. The sPositionBeamCenter/sPositionBeamPipe 
  // can be setted by SetPositionBeamCenter() and SetPositionBeamPipeCenter()
  return PositionShift(ixy, offsetx, offsety);
}

double RHICfSimP::GlobalPos_BeamPipe(int ixy){
  // Return the incident position in the global beam pipe coordinate.
  return PositionShift(ixy, 0.0, 0.0); 
}

void RHICfSimP::Clear(Option_t* option)
{
  TNamed::Clear(option);
  fPdgcode = 0;
  //fName = "";
  fFMomentum = TLorentzVector(0, 0, 0, 0);
  fPosition = TVector3(0, 0, 0);
  //fOriginalPName = "";
  //fOriginalP4Momentum = TLorentzVector(0, 0, 0, 0);
  //fOriginalPPosition = TVector3(0, 0, 0);
  fTrackID = 0;
  //fTower = -1;
}

void RHICfSimP::Copy(RHICfSimP& obj){
  TNamed::Copy(obj);
  fPdgcode = obj.fPdgcode;
  //fName    = obj.fName;
  fFMomentum = obj.fFMomentum;
  fPosition  = obj.fPosition;
  fTrackID   = obj.fTrackID;
}

// void RHICfSimP::SetName(TString tmps)
// {
//   fName = tmps;
// }

void RHICfSimP::Set4Momentum(TLorentzVector tmp4vec)
{
  fFMomentum = tmp4vec;
}

void RHICfSimP::SetPosition(TVector3 tmp3vec)
{
  fPosition = tmp3vec;
}

// void RHICfSimP::SetOriginalPName(TString tmps)
// {
//   fOriginalPName = tmps;
// }

// void RHICfSimP::SetOriginalP4Momentum(TLorentzVector tmp4vec)
// {
//   fOriginalP4Momentum = tmp4vec;
// }

// void RHICfSimP::SetOriginalPPosition(TVector3 tmp3vec)
// {
//   fOriginalPPosition = tmp3vec;
// }

void RHICfSimP::SetTrackID(Int_t tmpi)
{
  fTrackID = tmpi;
}

// void RHICfSimP::SetTower(Int_t tmptower)
// {
//   fTower = tmptower;
// }

// TVector3 RHICfSimP::GetFramePosition(const Double_t& offset)
// {
//   TVector3 tmpvec3;
//   return tmpvec3;
// }

RHICfSimP::RHICfSimP(const RHICfSimP &rhs): fPdgcode(rhs.fPdgcode),
														  //fName(rhs.fName),
														  fFMomentum(rhs.fFMomentum), 
														  fPosition(rhs.fPosition), 
														  //fOriginalPName(rhs.fOriginalPName),
														  //fOriginalPPosition(rhs.fOriginalPPosition), 
														  //fOriginalP4Momentum(rhs.fOriginalP4Momentum), 
														  fTrackID(rhs.fTrackID)
														  //fTower(rhs.fTower)
{;}

RHICfSimP& RHICfSimP::operator=(const RHICfSimP& rhs)
{
    TNamed::operator=(rhs);
    fPdgcode = rhs.fPdgcode;
	 //fName = rhs.fName;
    fFMomentum = rhs.fFMomentum;
    fPosition = rhs.fPosition;
    //fOriginalPName = rhs.fOriginalPName;
    //fOriginalPPosition = rhs.fOriginalPPosition;
    //fOriginalP4Momentum = rhs.fOriginalP4Momentum;
    fTrackID = rhs.fTrackID;
    //fTower = rhs.fTower;
    return *this;
}


  

#endif

